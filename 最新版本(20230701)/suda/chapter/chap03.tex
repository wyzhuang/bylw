\chapter{基于时间维度的样本重要性权重}
\label{chap:chap03}

这一章将在项目开发过程中预测模型迭代的场景下，基于更改级别的缺陷预测构建模型，并在模型构建的数据预处理阶段对样本施加基于时间维度的样本重要性权重。该方法可以有效利用项目样本的时间维度，通过让模型更关注较新提交的样本的方式提高模型的预测性能。

\section{研究动机}
即时软件缺陷预测旨在预测每次软件更改的缺陷可能性，通过项目的历史更改数据集构建训练模型，对新产生的提交进行预测。在实际的项目开发环境下，由于项目提交的先后顺序不同，所以提交样本具有明显的时间相关性。然而，即时软件缺陷预测领域研究者却很少关注项目提交的时间维度，最为典型的例子就是，仍然存在大量的研究工作\cite{DBLP:conf/msr/HoangDK0U19,DBLP:journals/ese/HuangXL19,kamei2016studying}采取K-折交叉验证的方式来对模型性能进行评估。在实际开发环境下，这种做法是不可能的，因为我们无法拿项目晚期的数据作为训练集来构建缺陷预测模型，并用于预测项目早期的数据。

除此之外，对于开发周期较长的软件项目，项目早期提交的风格往往与晚期提交的风格有着较大的差距，使得用项目早期数据构建的模型的性能表现往往会随时间推移而减弱。虽然相关研究\cite{DBLP:journals/tse/McIntoshK18}已经指出，对整个项目开发周期来言，用项目早期数据所构建的预测模型不能很好地预测项目晚期的模块是否具有缺陷，并且建议三到六个月就重新构建预测模型。但是目前仍然缺乏对于如何重新构建预测模型的研究，即如何平衡项目早期数据和新产生的数据，如何利用项目开发的时间维度，以及预测模型何时应该更新等等。

为了解决以上几个问题，本文将在更大的数据集上对相关研究\cite{DBLP:journals/tse/McIntoshK18}的观点进行验证，并提出一种基于时间维度的样本重要性权重，在模型迭代的场景下，进一步提高预测模型的性能。

\section{研究方法}
首先我们将定义如何在即时软件缺陷预测领域中预测模型迭代的过程。如图~\ref{chap03_fig_sketch}所示，对于项目内缺陷预测来言，一般已经有一部分历史故障信息(比如图~\ref{chap03_fig_sketch}中的[Commit\_1, Commit\_2, Commit\_3, Commit\_4 ... Commit\_n])，可以用它们来构建缺陷预测模型，在对新产生的未知样本进行预测后，交由测试人员进行审查，并打上标签，这样就会出现一批刚打上标签的样本(比如图~\ref{chap03_fig_sketch}中的[Commit\_n+1, Commit\_n+2, Commit\_n+3, Commit\_n+4 ... Commit\_m])。这些样本在被测试人员检查之后，将被输入模型中来更新训练集和预测模型，这样，更新后模型又能对新产生的一批无标签样本(比如图~\ref{chap03_fig_sketch}中的[Commit\_m+1, Commit\_m+2, Commit\_m+3, Commit\_m+4 ... Commit\_o])进行预测。

为了合理利用历史样本以及刚被打上标签的样本，构建更加准确的模型，每有一批新的刚被打上标签的样本，我们将用历史数据和新的有标签样本对模型进行重新训练，并对待测试样本进行预测。此时，被纳入训练的有标签样本都将成为故障信息库中的历史样本。随着项目继续开发一段时间，测试人员又会对新一批的样本打上标签，同时也会产生新一批待测试数据，这样不断重复之前的步骤，模型也会不断更新。
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.9\textwidth]{../fig/chp3/time_increment.pdf}
	\smallcaption{即时软件缺陷预测中模型迭代过程}
	\label{chap03_fig_sketch}
\end{figure}


除此之外，本文还利用了样本的时间维度来使模型能更多关注重要的样本，具体来说，我们首先进行项目划分，从项目中挑选出活跃的数据区间；其次，从这些数据区间的软件变更中提取出所有样本的特征；接着，我们对特征进行初步的数据规范化；然后，我们用时间衰减函数对样本施加基于时间维度的样本重要性权重；最后，将这些样本及其权重输入到机器学习模型中进行训练。

\subsection{项目划分}
本文所采用的数据集是Github上的开源数据集。由于在项目的实际开发中，项目的提交的活跃程度随着项目进度的变化而变化。在有新功能需求的时，项目开发较为活跃，提交较为频繁；而无新功能需求时，项目开发进入沉寂期，提交频率降低。如图~\ref{chap03_project_split}所示，以ant项目为例，从直方图中明显看出ant项目的提交数量是随着天数而波动的，具有明显的峰顶和谷底，峰顶表明项目在这一段时间进入活跃期，谷底则表明项目在这一段时间进入沉寂期。为了排除项目的活跃程度带来的干扰，本文从每个项目中寻找提交最频繁的5个阶段，这样保证提交的数量是足够的同时，也能保证数据的一致性和稳定性。

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.9\textwidth]{../fig/chp3/project_split.pdf}
	\smallcaption{从项目中寻找提交活跃期}
	\label{chap03_project_split}
\end{figure}

\subsection{特征提取}
本文所采用的是Kamei等人\cite{DBLP:journals/tse/KameiSAHMSU13}提出的14个特征。如表~\ref{chap03_tab_tra}所示，这些特性基于软件演化过程，从由于项目提交所产生的变动的影响、大小、目的、历史信息和开发者的经验等五个维度去描述提交所具有的缺陷倾向性。这些数据的大小是与提交的缺陷倾向性紧密相关的，因此它们被广泛应用于即时软件缺陷预测中\cite{fukushima2014empirical,DBLP:conf/sigsoft/YangZLZL0XL16,DBLP:conf/qrs/YangLXZS15,DBLP:journals/iet-sen/ZhuZYZ20}。

\begin{table}[width=.9\textwidth,pos=htbp]
	\smallcaption{14种更改特征的描述}
	\label{chap03_tab_tra}
	\centering
	
	\begin{tabular}{ccc}
		\hline
		特征类别 & 特征名 & 描述\\
		\hline
		\multirow{4}{*}{Diffusion}
		& NS & 修改子系统的数量 \cite{DBLP:journals/bell/MockusW00}\\
		& ND & 已修改目录的数量 \cite{DBLP:journals/bell/MockusW00}\\
		& NF & 修改文件的数量 \cite{DBLP:conf/icse/NagappanBZ06}\\
		& Entropy & 在每个文件中分发修改过的代码 \cite{DBLP:conf/icse/Hassan09}\\\hline
		\multirow{3}{*}{Size}
		& LA & 添加代码行数 \cite{DBLP:conf/icse/NagappanB05}\\
		& LD & 删除代码行数 \cite{DBLP:conf/icse/NagappanB05}\\
		& LT & 更改前文件中的代码行 \cite{DBLP:journals/tse/KoruZEL09}\\\hline
		\multirow{1}{*}{Purpose}
		& FIX & 变更是否是缺陷修复 \cite{DBLP:journals/tse/PurushothamanP05}\\\hline
		\multirow{3}{*}{History}
		& NDEV & 更改修改文件的开发人员数量 \cite{DBLP:journals/tse/GravesKMS00}\\
		& AGE & 上次更改和当前更改之间的平均时间间隔 \cite{DBLP:journals/tse/GravesKMS00}\\
		& NUC & 对修改文件的唯一更改数 \cite{DBLP:conf/icse/Hassan09}\\\hline
		\multirow{3}{*}{Experience}
		& EXP & 开发者的经验 \cite{DBLP:journals/bell/MockusW00}\\
		& REXP & 最近的开发人员的经验 \cite{DBLP:journals/bell/MockusW00}\\
		& SEXP & 开发人员在子系统上的经验 \cite{DBLP:journals/bell/MockusW00}\\
		\hline
	\end{tabular}
	
\end{table}

\subsection{数据规范化}
我们对数据集进行数据规范化，以消除不同度量的不同权重对预测模型和复杂度计算的负面影响。在应用数据规范化后，所有样本的度量都会落入一个类似的值范围，从而消除对任何特定度量的偏见。在本研究中，我们采用最小-最大归一化方法，将所有值调整到0到1的范围内。

\subsection{计算样本的时间权重}

除了特征复杂度之外，我们还利用样本的时间维度。具体来说，我们希望模型更重视接近现在时间的样本，为此，我们对样本加上一个时间权重，这个权重由时间衰减因子所控制，这样越靠近现在时间的样本，它的时间权重越高，会获得模型更多的关注；越是项目早期的数据，它的时间权重越低，对模型的影响越小。我们设计了三种不同的时间衰减函数，分别为线性衰减函数，指数衰减函数和高斯衰减函数，它们的表达式如下：

线性衰减函数：
\begin{equation}
\label{liner}
f(T)=W_{min}+\frac{W_{max}-W_{min}}{1+\sigma|T-t|}
\end{equation}

指数衰减函数：
\begin{equation}
\label{time}
f(T)=W_{min}+\frac{W_{max}-W_{min}}{e^{\sigma|T-t|}}
\end{equation}

高斯衰减函数：
\begin{equation}
\label{time}
f(T)=W_{min}+\frac{W_{max}-W_{min}}{\sigma\sqrt{2\pi}}e^{-\frac{1}{2}(\frac{T-t}{\sigma})^{2}}
\end{equation}
其中$f(T)$指目标样本的时间标签为$T$时，时间衰减因子的值；$W_{min}$和$W_{max}$分别代表样本的最小权重和最大权重。在本方法中对样本权重做归一化处理，即$W_{min}$设为0，$W_{max}$设为1；$\sigma$为衰减常数，与项目所挑选的活跃期长度有关；$T$表示目标样本的时间；$t$表示预测模型本次迭代的时间。目标样本时间越久远，$T$越小，$|T-t|$越大，而$f(T)$越小。


\subsection{模型训练}
生成时间权重之后，我们构建即时软件缺陷预测模型，每次重新训练模型时，以样本的时间权重作为训练时的样本权重，让模型注重学习较重要的样本。在模型构建上，我们选取随机森林 (Random Forest, RF) 和逻辑回归 (Logistic Regression, LR) 作为分类器，这两种分类器常用于软件工程实证研究工作的建模中\cite{DBLP:conf/wcre/MoralesMK15, DBLP:conf/icse/ZhouM11}。

\section{实验设置}

这一节主要介绍本次实验中的实验数据集和描述、对比实验设置、性能评价指标等相关设置。

\subsection{实验数据集}

本文所挑选的项目来自Apache和Github上的开源项目，这些项目开发时间较长，足以支撑起本文的研究工作，并且也在软件工程领域被研究人员所广泛使用\cite{DBLP:journals/tse/KameiSAHMSU13,DBLP:conf/qrs/YangLXZS15,DBLP:journals/iet-sen/ZhuZYZ20}。它们的名称、描述、总时长、所挑选的活跃期长度、提交总数以及缺陷比例如表~\ref{tab_project}所示。项目的总时长在2至20年之间，因此有不同时间跨度的项目可以更加全面地反映模型对不同项目的适配性。有7个项目期限超过10年，说明这些项目都具有足够长的时间跨度并产生足够多的提交用于我们的研究和实验。项目总提交的数量在8845到49927之间，所挑选的活跃期长度在5至20个月之间。这些数据都意味着这些项目足以进行实证研究。缺陷率在9\%到26\%之间，这意味着在模型训练过程中会出现类不平衡的问题，导致模型的预测性能的评估可能出现偏差，为了保证实验公平，本章的所有方法都没有采用类不平衡技术，这样实验结果的有效性是有保障的。

为了获取这些项目在开发周期中的每次提交产生的变更，以及变更所对应的特征，我们采取比较成熟的一种对提交的分析和风险预测技术~\cite{DBLP:conf/sigsoft/RosenGS15}来提取项目开发过程中产生的提交，并生成如表~\ref{chap03_tab_tra}所示的各类度量。这个技术已经被广泛应用于各类对项目代码提交的研究当中\cite{DBLP:journals/ieicetd/MonKCM23,DBLP:conf/icsm/KazemiLM22,DBLP:journals/ase/NadimMR22}，受到广泛认可，生成的数据集具有较高的可靠性。

另外需要注意的是，由于我们对每个项目都挑选了5个活跃期来作为缺陷预测的任务数据，因此总共可以划分出50(5*10)个任务数据集，在每个数据集上我们依据时间进行划分成10个时长相等的阶段，在这10个阶段上进行模型迭代，第一个阶段作为历史数据集，剩下九个阶段在每次模型迭代中依次输入训练集，即在每个数据区间上，预测模型迭代9次，这样共生成了450个缺陷预测任务。
\begin{table}[!htbp]
	\smallcaption{数据集描述}
	\Large
	\label{tab_project}
	\centering
	\resizebox{\textwidth}{!}{
		\begin{tabular}{cccccc}
			\hline
			项目 & 描述  & 总时长(月/年) & 活跃期长度(月) & 提交总数 & 缺陷比例(\%) \\\hline
			ambari     & 管理Hadoop集群的工具 &09/2011-06/2020 & 10 & 24588    & 22\\
			ant   & 基于java的构建工具&01/2000-08/2020 & 20 & 14667    & 24\\
			aptoide & Android App Store客户端 &04/2016-11/2020 &5 & 12981  & 22\\
			camel  &    一个强大的开源集成框架 &03/2007-02/2021 & 15 & 49927 &23\\
			cassandra & 高度可扩展的分区行存储 &03/2009-01/2021 & 10 & 25936 & 14\\
			egeria & 开放的元数据和管理类型系统 &06/2018-02/2021 & 5  &12707 & 9\\
			felix   & 一个实现OSGi R4规范的项目 &08/2005-03/2020 & 15 & 15556  & 19\\
			jackrabbit   & JCR的实现 &09/2004-08/2020 & 15   & 8845    & 20\\
			jenkins  & 开源自动化服务器 &11/2006-08/2020 & 15 & 29447  & 17\\
			lucene   &  开源搜索软件 &09/2001-08/2020 & 20    & 34317    & 26\\
			\hline
		\end{tabular}
	}
\end{table}




\subsection{对比方法}

为了能更充分地展现本文提出的方法的性能表现，这一节将选取以下方法作为对比：

(a)TRD (Tradition)~\cite{DBLP:conf/qrs/TianLTZ20}: 每次模型迭代数据集不会更新，仅使用项目早期数据去预测项目晚期数据的模型。

(b)Base~\cite{DBLP:journals/ijseke/ChenSW21}: 每次模型迭代使用项目的所有历史数据作为训练集，去预测新的阶段的样本是否有缺陷。

(c)SP (Short Period)~\cite{DBLP:journals/tse/McIntoshK18}: 每次模型迭代仅使用最新阶段的数据作为训练集，其他历史数据均抛弃掉。

(d)TBW (Time-based Weights)+liner: 在Base模型的基础上使用线性衰减函数作为样本权重系数。

(e)TBW+exp: 在Base模型的基础上使用指数衰减函数作为样本权重系数。

(f)TBW+gauss: 在Base模型的基础上使用高斯衰减函数作为样本权重系数。

\subsection{评价指标}


本文主要采取非工作量感知场景下的性能评价指标，非工作量感知场景指开发或测试人员对缺陷预测模型给出的结果进行人工核查时，相关资源能够满足对所有被报告有缺陷的测试样本均进行核查的场景。在这样的场景下，用于缺陷预测任务的性能评价指标应该与一般的分类任务的评价指标相同。因此，本研究选择了在分类任务中广泛使用的$Acc$，$F1$和$Mcc$\cite{DBLP:journals/bioinformatics/BaldiBCAN00}作为本文的性能评价指标。

$Acc$是评价机器学习模型性能的最常见指标，$F1$则是$Precision$和$Recall$的调和平均值。在缺陷预测模型的性能表现中，较高的$Precision$值表明模型预测为有缺陷的样例中，真正含有缺陷的比例越高，这将减少浪费在检查假阳性样本的相关资源；较高的$Recall$值则表明模型能够识别出更多确实含有缺陷的样例，通常这对于安全攸关的软件来说极为重要。然而，$Precision$和$Recall$都有各自的局限性，并不能全面地反映模型的性能表现。例如，一个输出全为$True$地模型的$Recall$值总是1，但这样的预测结果不具有参考意义。因此，本文选取了$F1$来均衡$Precision$和$Recall$，并作为本文工作的评价指标。

\begin{sloppypar}
虽然$F1$广泛用于软件缺陷预测领域，但一些研究\cite{DBLP:journals/tse/SongGS19}指出由于$F1$忽略了$True\;Negative$，它仍然无法很好地评估不平衡域下的性能。 因此在本文中，我们选取了马修斯相关系数(Matthews Correlation Coefficient, MCC)\cite{DBLP:journals/bioinformatics/BaldiBCAN00}, 一个用于衡量不平衡数据下的模型性能的度量\cite{DBLP:journals/tse/ShepperdBH14}，来更全面地评估本文方法的性能表现。 $MCC$指标考虑了真阳性(True Positive, TP)、真阴性(True Negative, TN)和假阳性(False Positive, FP)和假阴性(False Negative, FN)，具体定义如下:
\end{sloppypar}
\begin{equation}
MCC=\frac{TP \times TN-FP \times FN}{\sqrt{(TP + FP)(TP + FN)(TN + FP)(TN + FN)}}
\end{equation}
$MCC$展现标准互信息度量算法结果与标准结果之间的相似度，取值范围为[-1，1]，其中1表示模型预测的分类和实际分类完全正相关，0表示无关联，-1表示完全负相关，$MCC$值越大说明模型效果越好。

最后，为了排除随机因素的干扰，我们在每个任务上的实验都重复三十次，来获得更加可靠的实验结果。

\section{实验结果和分析}
在这一节，本文将本文方法与其他方法进行对比，并对实验结果进行分析。

\subsection{三种时间衰减因子的性能比较}

在本小节中，我们探讨三种时间衰减因子的性能比较。三种时间衰减因子各有不同，线性衰减因子的衰减速率总是一致的，指数衰减因子的衰减速率是越来越大，高斯衰减因子的衰减速率是先增大后减少，具体哪一种衰减因子更适合即时软件缺陷预测，我们在50个数据区间上进行实验来验证。对于每个时间衰减因子参数$sigma$，都调节到使得预测模型性能最优。最后我们会选取最优的时间衰减因子作为本文工作的方法与其他方法进行比较。

如图~\ref{chap03_ablation_all}所示，我们采取SK(Scott \& Knott)图\cite{scott1974cluster}来表现不同方法之间的性能差异。在图中，模型根据预测性能从左到右排序，性能相当的模型的框用相同的颜色表示。从图中可以看出，在指标$Acc$上，TBW+exp性能最高，平均值为0.775，TBW+gauss的性能最低，为0.772。 而在$F1$和$MCC$上，TBW+gauss的性能最高，分别为0.459和0.331，TBW+liner的性能最低，分别为0.441和0.325。不过三种函数的图像颜色相同，说明当参数最优时，这三种衰减因子的性能差异并不大。

从综合考虑，TBW+gauss在两个指标上的性能都是最优，而在$Acc$仅与最优相差0.003，因此本文在与其他方法进行对比时，都采用高斯衰减函数作为本章所提方法的时间衰减因子。

\begin{figure}[!h]
	\centering
	\subfigure{
		\begin{minipage}[t]{0.45\linewidth}
			\centering
			\includegraphics[width=\textwidth]{../fig/chp3/3_ablation_Acc.pdf}
			\centerline{ \small (a) Acc上的性能差值}
		
			
		\end{minipage}
    }
	\subfigure{
		\begin{minipage}[t]{0.45\linewidth}
			\centering
			\includegraphics[width=\textwidth]{../fig/chp3/3_ablation_f1.pdf}
			\centerline{\small (b) F1上的性能差值}
		\end{minipage}
		
	}
	\subfigure{
	\begin{minipage}[t]{0.45\linewidth}
		\centering
		\includegraphics[width=\textwidth]{../fig/chp3/3_ablation_MCC.pdf}
		\centerline{\small (c) MCC上的性能差值}
	\end{minipage}
	
}

	\smallcaption{三种时间衰减系数的性能差异}
	\label{chap03_ablation_all}
\end{figure}



\subsection{与对比方法的性能比较}

在本小节中，我们将本文提出的基于时间维度的样本重要性权重与其他方法进行比较，它们的性能如图~\ref{chap03_res_Acc}，图~\ref{chap03_res_F1}和图~\ref{chap03_res_MCC}所示。对于指标$Acc$，模型按照性能从优到劣进行排序，分别为TBW+gauss、Base、SP以及TRD，平均值分别为0.772、0.769、0.755和0.733；对于指标$F1$，模型按照性能从优到劣进行排序，分别为TBW+gauss、TRD、SP以及Base，平均值分别为0.459、0.430、0.429和0.425；对于指标$MCC$，模型按照性能从优到劣进行排序，分别为TBW+gauss、Base、SP以及TRD，平均值分别为0.331、0.306、0.287和0.272。

从总体上来看，本文提出的TBW+gauss总是在图的最左边，并且平均值也是最高的，表明在所有指标上，TBW+gauss总是最优的，这说明了我们提出的基于时间维度的样本权重是有意义的。此外，传统的即时预测模型TRD的性能表现不佳，说明了模型迭代本身对即时软件缺陷预测也是具有重大意义的。对于SP，我们将其纳入对比方法是因为有研究人员\cite{DBLP:journals/tse/McIntoshK18}只用最新的数据作为训练集，结果要比把所有数据都作为训练集效果要好；不过从我们的实验结果来看，似乎并不总是这样，有历史数据信息的模型往往表现更好。而Hoang等人\cite{DBLP:conf/msr/HoangDK0U19}的研究和我们的实验结果相似。这说明不能简单地抛弃项目早期的数据，因此我们采取时间权重的方式，只让模型重点关注比较接近当前时间的数据。

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.6\textwidth]{../fig/chp3/3_res_Acc.pdf}
	\smallcaption{基于时间维度的样本重要性权重与其他方法在Acc值上的性能差异}
	\label{chap03_res_Acc}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.6\textwidth]{../fig/chp3/3_res_F1.pdf}
	\smallcaption{基于时间维度的样本重要性权重与其他方法在F1值上的性能差异}
	\label{chap03_res_F1}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.6\textwidth]{../fig/chp3/3_res_MCC.pdf}
	\smallcaption{基于时间维度的样本重要性权重与其他方法在MCC值上的性能差异}
	\label{chap03_res_MCC}
\end{figure}






\subsection{参数实验和讨论}

这一节主要讨论在即时软件缺陷预测领域，窗口期的大小对模型性能的影响。在这里我们以两个元素分别作为窗口期：固定时长和固定样本数量。固定时长是由于在即时软件缺陷预测中，项目的提交具有明显的时间顺序，包括本文的研究是以时间权重作为研究内容，因此时长是值得关注的一个元素。固定样本数量是因为，在即时软件缺陷预测研究中，仍然存在大量的研究工作是以样本数量作为训练集和测试集的划分依据，即以固定样本数量作为训练集，剩下的作为测试集，因此本文也将固定的样本数量作为关注的一个元素。

在本参数实验中，由于任务数据集的大小是固定的，因此窗口期越大，每次模型迭代模型时输入的数据越多，迭代的次数越少。反之，窗口期越小，输入的数据越少，迭代次数越多。

(1)按照时间划分窗口期

对于时间窗口期，我们按比例进行划分。如图~\ref{chap03_para_all} (a)所示，我们将缺陷预测模型每次迭代的时长分别划分为总时长的50.00\%、33.33\%、25.00\%、20.00\%、16.67\%、12.50\%、10.00\%、8.33\%、6.67\% 和5.00\%。值得注意的是，当时间窗口期为50\%时，相当于拿项目早期50\%时长的数据，去预测项目晚期50\%时长的数据，这样我们实际上并没有对预测模型进行迭代，训练集和测试集的划分将与传统的即时软件缺陷预测方法类似。但是与之不同的是，为了确保参数实验的前后一致性，我们仍然对训练集施加时间权重。

从图~\ref{chap03_para_all} (a)可以看出，对于$F1$,$MCC$和$Acc$，这三个指标的性能都会随着窗口期的减小而增大，这意味着在同样的数据集上，模型迭代的次数越多，模型的性能越好。从图中可以看出，模型性能在横坐标为8.33\%至5.00\%的范围内变化幅度比12.5\%至8.33\%大一些，这是因为横坐标为5.00\%时，划分为20个阶段；横坐标为8.33\%时，划分为12个阶段；横坐标为12.5\%时，划分为8个阶段。因此8.33\%至5.00\%多了8个阶段，12.5\%至8.33\%只多了4个阶段；这也使得横坐标在8.33\%至5.00\%上升比较明显。

这个结果对于实际项目中进行即时软件缺陷预测是具有实际意义的，结果表明，在测试资源允许的情况下，我们应该尽可能频繁地去更新预测模型，以获得更高的预测性能。在本文中，考虑到我们在50个数据区间上的实验工作量较为庞大，受到服务器性能的制约，我们采用10\%作为预测模型迭代的窗口期，而不是最高的5\%，但即便如此，我们的方法也比其他方法更加优秀。

\begin{figure}[!h]
	\subfigure{
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{../fig/chp3/3_para_timestep.pdf}
		\centerline{\small (a) 按照时间划分窗口期}
		
	\end{minipage}
     }
 \subfigure{
	\begin{minipage}[t]{0.5\linewidth}
		\centering
		\includegraphics[width=\textwidth]{../fig/chp3/3_para_samplestep.pdf}
		\centerline{\small (b) 按照样本数量划分窗口期}
	\end{minipage}
	
	 }
 \smallcaption{参数实验结果}
 \label{chap03_para_all}
\end{figure}




(2)按照样本数量划分窗口期

在相关即时软件缺陷预测研究中~\cite{DBLP:conf/msr/HoangDK0U19,DBLP:journals/ese/HuangXL19,kamei2016studying}，一些研究人员以样本数量作为划分依据，比如用固定比例的样本数量作为训练集，去预测剩下的样本；或者采取X折交叉验证的方式。另一方面，考虑到在实际开发过程中，测试人员可以在提交的数量足够多时来更新缺陷预测模型，这样的做法也是具有实际意义的。即项目活跃的时候预测模型更新会变得较为频繁，项目不活跃的时候预测模型更新会变得较为缓慢。因此我们也把样本数量作为窗口期进行实验研究。

与时间窗口期类似，我们将缺陷预测模型每次迭代的样本数量分别划分为总样本数量的50.00\%、33.33\%、25.00\%、20.00\%、16.67\%、12.50\%、10.00\%、8.33\%、6.67\% 和5.00\%。在每次模型迭代学习的过程中，我们也同样按照本文的方法对不同的任务给予相应的时间权重。结果如~\ref{chap03_para_all} (b)所示，实验结果随着窗口期的减小而增大，这意味着以样本数量来划分窗口期时，缺陷预测模型的性能也同样随着迭代次数的增大而增加。


以上的窗口期参数实验表明，在数据集时长和总样本数量一定的情况下，预测模型迭代的越频繁，模型性能越高。这意味着在实际项目开发过程中，测试人员应该频繁地更新预测模型，而不是像传统即时软件缺陷预测那样，只用项目早期的数据作为训练集，去预测项目晚期的数据。



%(2)数据集时长大小对模型迭代的影响

%在讨论完数据集大小固定，模型迭代次数不固定之后，本小节对模型迭代次数固定，数据集大小不固定的实验结果进行讨论。在本小节中，以时间作为窗口期，窗口期大小为10\%，来进行即时软件缺陷预测。值得注意的是，虽然本文所研究的十个项目的时长各不相同，已经可以满足本小节的研究需求，但是由于不同项目在时长不同的同时，其他的各个方面也不尽相同(比如开发人员的经验，项目风格等等)，会给实验结果带来偏差。因此，为了尽量减小项目本身对模型性能的影响，本小节只以$lucene$，一个长达20年的项目作为源数据集。并如图~\ref{chap03_para_length}所示，分别挑选时长为10月、15月、20月、25月、30月以及40月作为模型迭代的任务数据集。每个任务数据集中的样本都是连续的，且都是选择项目最活跃的时间段。

%从图~\ref{chap03_para_length}可以看出，随着数据集大小的增加，实验结果呈现较无规律的波动性，而并不像之前两个参数实验具有明显的倾向性。我们仔细检查了实验数据和实验结果，对此做出一些解释。首先，我们挑选的都是实际的数据，当数据集的总时长增大时，数据集中的数据也会增加，这样并没有严格地控制变量，会给实验结果带来偏差。不过这几乎是难以避免的，除非自己构造数据。此外，由于我们总是贪婪地去寻找最活跃的提交区间，所以有时会使得挑选的数据产生较大的差别。比如，以图~\ref{chap03_para_length}中时长为20月和25月为例，它们的性能之所以产生这么大的波动，是因为活跃期时长为20月的数据和活跃期时长为25月的数据是具有非常大的差别的。另外从10月、15月和20月的结果来看，由于它们的数据是比较一致的，即20月的数据包含10月和15月的数据，这样它们的结果呈现一定的随数据集长度的增大而预测模型的效果获得提升的规律，这样可以说明数据集的大小对于模型迭代效果仍然具有一定的影响。


%\begin{figure}[!h]
%	\centering
%	\includegraphics[width=0.9\textwidth]{../fig/chp3/3_para_length.pdf}
%	\smallcaption{不同长度的数据集的性能比较(以lucene项目为例)}
%	\label{chap03_para_length}
%\end{figure}

结合以上两个图可知，当数据集大小相同时，窗口期越小，模型迭代的越频繁，模型性能越强。这证明了模型迭代在即时软件缺陷预测领域的有效性和必要性。对于项目开发过程中，具体应该多长时间来更新缺陷预测模型，根据我们的实验结果以及相关的研究\cite{DBLP:journals/tse/McIntoshK18}，我们推荐每隔3或6个月就应该更新一次缺陷预测模型，当然，如果测试资源允许，去更加频繁地更新缺陷预测模型，也能获得更好的预测性能。

%对于数据集的总时长对模型性能的影响，由于难以排除数据集中数据的变化对实验结果产生的干扰，使得参数实验结果没有在宏观上呈现绝对的规律性。不过观察局部数据相似的地方，实验结果呈现随着数据集的增大而提高的趋势，这说明在实际开发中，开发时长较长的项目更应该采取积极地去更新缺陷预测模型。

(3)本章方法的时间开销

由于本章方法在基础方法上添加了时间权重，考虑到测试资源是有限的，因此本章所提出的权重的时间开销是值得考虑的事情。如表~\ref{chap03_tab_time_cost}所示，表里列举了三种时间衰减因子在每个项目上生成时间权重所需时间开销之和。从表中可以看出，在时间开销最大的项目lucene上，三种时间衰减函数的时间开销都小于2毫秒，因此本章权重的时间开销是完全可以接受的；由于时间权重的生成时间开销只与样本数量相关，因此样本数量越多的项目所需要的时间开销越大，考虑到模型训练的时间同样也随样本数量成正比，而本章方法的时间开销在样本数量相同的情况下远小于模型训练的时间，因此可以认为本章方法所提出的权重并不会造成很多额外的测试资源花费。
\begin{table}[width=.9\textwidth,pos=htbp]
	\smallcaption{三种时间衰减函数的时间开销}
	\label{chap03_tab_time_cost}
	\centering
	
	\begin{tabular}{cccc}
		\hline
		项目 &TBW+liner(毫秒) &TBW+exp(毫秒) &TBW+gauss(毫秒) \\\hline
		ambari     &0.97   &0.97   &0.94    \\
		ant        &0.56   &0.55   &0.52    \\
		aptoide    &0.44   &0.43   &0.44    \\
		camel      &0.96   &0.94   &0.93    \\
		cassandra  &0.81   &0.79   &0.82    \\
		egeria     &0.66   &0.68   &0.67    \\
		felix      &0.59   &0.60   &0.60    \\
		jackrabbit &0.34   &0.36   &0.34    \\
		jenkins    &1.10   &1.05   &1.10    \\
		lucene     &1.29   &1.20   &1.22    \\
		
		\hline
	\end{tabular}
\end{table}


\section{本章小结}

本章在即时软件缺陷预测领域，基于少有人关注的时间维度，探究提交的时间对预测模型的影响，以及如何去利用时间维度来增强即时预测模型。本文设计了三种不同的时间衰减因子，在10个项目，每个项目5个数据区间上，9次模型迭代上进行实证研究，通过三种评价指标评估模型性能，并将本文的方法与其他方法进行比较，最终的实验结果表明了模型迭代的必要性，并且验证了本文所提出的基于时间维度的样本重要性权重的有效性。接着，我们还对时间窗口期和样本数量窗口期对缺陷预测模型迭代的影响进行了实证研究，结果表明，加快预测模型的迭代频率可以在总体上获得性能的提升。最后，我们还对方法的时间开销进行分析，表明我们方法在时间开销上并没有太大花费。